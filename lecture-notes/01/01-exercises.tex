\documentclass{article}
\usepackage{crysymb}
\usepackage{crypto-ii}
 
\begin{document}

\noindent	
MTAT.07.003 Cryptology II\\
Fall 2014 / Exercise session I  

\begin{enumerate}

\item A company holds electronic lotteries briefly described below.
  \begin{quote}
    A secure hardware is used to generate the output
    $x\in\set{0,1}^{20}$.  The input $x$ is fed into a specially
    designed garbling algorithm (worldwide patented), which takes in
    $x$ and broadcasts a garbled output $y$ to everybody.  All
    participants submit their guesses $q_i$ about $x$. The company
    releases $x$ and everybody uses the description of the garbling
    algorithm to verify that $y$ was computed form $x$. The one who
    guessed $x$ gets a prize.
  \end{quote}

  \begin{enumerate}
  \item Formalise the lottery system using abstract primitives for
    appropriate actions. Describe such functional requirements that
    the organiser cannot cheating and that participants can verify the
    correctness.
  \item Define an attack scenario where participants try to
    cheat. Quantify the success of the malicious
    participant. Formalise the corresponding security definition.
  \item Show that no garbling algorithm can meet functional
    requirements and be secure at the same time.
  \end{enumerate}
 
\item A standard way to protect data against malicious corruption is
  hashing. Namely, there are many industry standard algorithms, like
  MD5, SHA-256 and WHIRLPOOL, that take in a long file and output a
  short digest. If the digest is securely stored, then the validity of
  the file can be tested by recomputing the digest and comparing it to
  the stored value.
  \begin{enumerate}
  \item Formalise the functional requirements and describe the attack
    scenario if the original data is generated by flipping a fair coin.
  \item Describe the attack scenario if an attacker gets to know the
    randomly generated original data before spoofing the file. 
  \item Describe the attack scenario if attacker can influence the
    content of the original file. Show that no function can be secure
    against such attacks. What does it mean in real life applications?
  \end{enumerate}

\item Salted hashing is common mechanism for storing passwords. Each
  user is first granted an identifier \texttt{id}. Every time the
  password is hashed, the identifier \texttt{id} is appended to it and
  then a system-wide hash function is used to compute the digest. The
  authentication is successful if the digest coincides with the digest
  stored in \texttt{passwd} file.
  \begin{enumerate}
  \item Formalise the system by using abstract primitives for
    appropriate actions. Describe the functional requirements that are
    needed for seamless authentication. Compare the formalisation with
    the lottery system described in the first exercise.
  \item Define an attack scenario where the attacker tries to reverse
    engineer passwords from salted hashes. Formalise the corresponding
    security condition. Can this security condition be met in
    practice?
  \item Extend the attack description to the setting where the
    identifier \texttt{id} depends on the identity of a user. What
    does such a design choice give to the attacker? Modify the
    corresponding attack scenario and derive the corresponding
    security requirement.
  \end{enumerate}


  
\item Let $\GG$ be a finite group such that all elements $y\in\GG$ can
  be expressed as powers of $g\in\GG$. Then the Computational
  Diffie-Hellman (CDH) problem is following. Given $x=g^a$ and
  $y=g^b$, find a group element $z=g^{ab}$.
  \begin{enumerate}
  \item Show that Computational Diffie-Hellman problem is random
    self-reducible, i.e., for any algorithm $\ADB$ that achieves
    advantage
    \begin{align*}
      \advCDHXX{\GG}{\ADB}\doteq\pr{x,y\getsu\GG: \ADB(x,y)=g^{\log_g
          x\log_g y}}
    \end{align*}
    there exists an oracle algorithm $\AD^{\ADB}$ that for any input
    $x,y\in\GG$ outputs the correct answer with the probability
    $\advCDHXX{\GG}{\ADB}$ and has roughly the same running time.
  \item Given that the CDH problem is random self-reducible, show that
    the difficulty of CDH instances cannot wary a lot. Namely, let
    $\ADB$ be a $t$-time algorithm that achieves maximal advantage
    $\advCDHXX{\GG}{\ADB}$. What can we say about worst-case advantage
    \begin{align*}
      \min_{x,y}\pr{\AD(x,y)=g^{\log_g x\log_g y}}?
    \end{align*}
    Can there be a large number of pairs $(x,y)$ for which the CDH problem
    is easy?
  \end{enumerate}
  \item Let $\GG$ be a finite group such that all elements $y\in\GG$ can
  be expressed as powers of $g\in\GG$. Then the Decisional
  Diffie-Hellman (DDH) problem is following. Given $x=g^a$ and
  $y=g^b$ and $z$, decide whether $z=g^{xy}$ or not.
  \begin{enumerate}
  \item Show that Decisional Diffie-Hellman problem can be reduced to
    Computational Diffie-Hellman problem, i.e., for any algorithm
    $\AD$ that achieves advantage $\advCDHXX{\GG}{\AD}$, there exists
    an oracle algorithm $\ADB^{\AD}$ that has has roughly the same
    running time and that the advantage
    \begin{align*}
      \advDDHXX{\GG}{\ADB}\doteq
      \abs{\pr{\begin{aligned}
        &x,y,z\getsu\GG:\\ 
        &\ADB(x,y,z)=1
      \end{aligned}}-
      \pr{\begin{aligned}
        &x,y\getsu\GG, z\gets g^{\log x\log y}:\\ 
        &\ADB(x,y,z)=1
      \end{aligned}}}
    \end{align*}
    is roughly equal to the advantage $\advCDHXX{\GG}{\AD}$. 
  \item Provide a  reductions between DL, CDH and DDH problems.
  \item Show that if there exists an efficient procedure that can
    always compute the highest bit of $\log_g y$ then the DL problem
    is easy.
  \item[($\star$)] As the Decisional Diffie-Hellman problem is
    randomly self-reducible, it is possible to construct an algorithm
    that amplifies the advantage by running $\ell$ instances of the
    base algorithm to provide an aggregated answer. Give a detailed 
    analysis of such an amplifier construction $\ADC$ and show upper and 
    lower bounds for the success. Estimate the gap between these bounds
    when $\ell\to\infty$.
  \end{enumerate}
\end{enumerate}
\end{document} 