\documentclass{crypto-exercise}
\usepackage{amsthm}
\author{Sven Laur}
\contributor{Sven Laur}
\editor{Sven Laur}
\tags{Simultaneous message exchange, input extraction, output equivocation, stateful protocols}

\newcommand{\REWRITE}{\qquad\scalebox{1.5}{$\rightsquigarrow$}\qquad}

\newcommand{\CS}{\mathcal{C}om}
\newcommand{\IEXTR}{\mathscr{K}}
\newcommand{\OEQUIV}{\mathscr{E}}
\newcommand{\FAIL}{\mathsf{Fail}}
\newcommand{\ELIF}{\mathsf{else\ if}\ }

\makeatletter
%\newcommand{\xleftrightarrow}[2][]{\ext@arrow 3359\leftrightarrowfill@{#1}{#2}}
\newcommand{\xdashrightarrow}[2][]{\ext@arrow 0359\rightarrowfill@@{#1}{#2}}
\newcommand{\xdashleftarrow}[2][]{\ext@arrow 3095\leftarrowfill@@{#1}{#2}}
\newcommand{\xdashleftrightarrow}[2][]{\ext@arrow 3359\leftrightarrowfill@@{#1}{#2}}
\def\rightarrowfill@@{\arrowfill@@\relax\relbar\rightarrow}
\def\leftarrowfill@@{\arrowfill@@\leftarrow\relbar\relax}
\def\leftrightarrowfill@@{\arrowfill@@\leftarrow\relbar\rightarrow}
\def\arrowfill@@#1#2#3#4{%
  $\m@th\thickmuskip0mu\medmuskip\thickmuskip\thinmuskip\thickmuskip
   \relax#4#1
   \xleaders\hbox{$#4#2$}\hfill
   #3$%
}
\makeatother

\begin{document}


\begin{exercise}{Security of simultaneous message exchange protocol}
Analyse security of the following  simplistic protocol for simultaneous message exchange 
\begin{align*}
&\PARTY_1(x_1) &&  &&\PARTY_2(x_2) \\
&&\xdashleftrightarrow[\hspace*{2cm}]{\fbox{$\PK\gets\GEN$}\atop {\phantom{ \textstyle c} \atop\PK}}\\
&(c,d)\gets\COM_\PK(x_1)\\
&&\xrightarrow[\hspace*{2cm}]{\PK,c}\\
&&\xleftarrow[\hspace*{2cm}]{x_2}\\
&&\xrightarrow[\hspace*{2cm}]{d}\\
&&&&& x_1\gets\OPEN_\PK(c,d)\\
&\RETURN (x_1,x_2)
&& &&\RETURN (x_1,x_2)
\end{align*}
where bits $x_1$ and $x_2$ are private protocol inputs and a triple of algorithms $(\GEN,\COM,\OPEN)$ is  a commitment scheme $\CS$ with appropriate properties. The dashed line denotes sub-protocol for fixing the commitment parameters. 
Prove that there exist an efficient simulator for $\PARTY_1$.
\end{exercise}

\begin{solution}
\ \\
\textsc{Right ideal implementation.}
As the first party $\PARTY_1$ can refuse to open its input based on the opponents input $x_2$, we must consider the  idealised functionality where the first party $\PARTY_1$ is in the dominant position:
\begin{align*}
&\PARTY_1(x_1) &&&& \TTP  &&&&\PARTY_2(x_2) \\
&&&\xrightarrow[\hspace*{2cm}]{x_1}
&&&\xleftarrow[\hspace*{2cm}]{x_2}\\
&&&\xleftarrow[\hspace*{2cm}]{x_2}\\
&&&\xrightarrow[\hspace*{2cm}]{\textsc{Abort}/\textsc{Continue}}\\
&&&&&&\xrightarrow[\hspace*{2cm}]{x_1}\\
&\RETURN (x_1,x_2)
&&&&&&&&\RETURN (x_1,x_2)
\end{align*}

\noindent
\textsc{High-level descriptions for simulator constructions.}
Assume that the first party $\PARTY_1$ is malicious. Then the corresponding simulator $\SIM$ must first provide an input $\hat{x}_1$ to the trusted third party $\TTP$ who replies $x_2$. After that it can still abort ideal computations by sending $\textsc{Abort}$ signal. If the commitment parameters are generated by $\PARTY_1$, the corresponding simulator construction can be defined as follows 
\begin{align*}
\begin{fblock}{\SIM(\phi_1,x_1)}
& \omega_1\getsu\Omega_1\\
& (\PK,c)\gets\PARTY_1^*(\phi_1,x_1;\omega_1)\\ 
& \hat{x}_1\gets \IEXTR(\phi_1,x_1,\omega_1)\\
& \text{Send $\hat{x}_1$ to $\TTP$ and store the reply as $x_2$.}\\
& d\gets \PARTY_1^*(x_2)\\ 
& \IF \OPEN_\PK(c,d)= \bot\ \THEN \\
&\begin{cblock}
& \text{Send \textsc{Abort} to $\TTP$}\\
& \RETURN \PARTY_2^*(\bot)
\end{cblock}\\
& \ELIF \OPEN_\PK(c,d) = \hat{x}_1\ \THEN\\
&\begin{cblock}
& \text{Send \textsc{Continue} to $\TTP$}\\
& \RETURN \PARTY_2^*(x_2)
\end{cblock}\\
& \ELSE \RETURN \FAIL\\
\end{fblock}
\end{align*}
If commitment parameters are generated by $\PARTY_2$ then the input extractor $\IEXTR$ must accept $\PK$ as an extra argument and the resulting simulator is somewhat different
\begin{align*}
\begin{fblock}{\SIM(\phi_1,x_1)}
& \omega_1\getsu\Omega_1\\
& \PK\gets\GEN\\
&  c\gets\PARTY_1^*(\phi_1,x_1,\PK;\omega_1)\\ 
& \hat{x}_1\gets \IEXTR(\phi_1,x_1,\PK,\omega_1)\\
& \text{Send $\hat{x}_1$ to $\TTP$ and store the reply as $x_2$.}\\
& d\gets \PARTY_1^*(x_2)\\ 
& \IF \OPEN_\PK(c,d)= \bot\ \THEN \\
&\begin{cblock}
& \text{Send \textsc{Abort} to $\TTP$}\\
& \RETURN \PARTY_2^*(\bot)
\end{cblock}\\
& \ELIF \OPEN_\PK(c,d) = \hat{x}_1\ \THEN\\
&\begin{cblock}
& \text{Send \textsc{Continue} to $\TTP$}\\
& \RETURN \PARTY_2^*(x_2)
\end{cblock}\\
& \ELSE \RETURN \FAIL\\
\end{fblock}
\end{align*}
 



\medskip
\noindent
\textsc{\textcolor{red}{(a)} Input extractor for $\PARTY_1$.}
As the simulator must work universally well for all inputs $(\phi_1, x_1)$, the actual input $\hat{x}_1$ must be extracted form $\PARTY_1$ in a black-box manner. Indeed, consider a specific adversary $\PARTY_1^*$ that treats input $\phi_1$ as the code and just interprets it to determine its actions. Depending on the precise computational model, such an interpretation is either linearly or quadratically slower than the dedicated attacker $\hat{\PARTY}_1^*$ and we loose in efficiency. However, we gain universality -- the input extractor $\IEXTR$ must works for all these attacks. Theoretically, the extractor $\IEXTR$ can use the code $\phi_1$ to fine-tune its actions. However, so far nobody knows how to efficiently extract information from the program code and thus black-box execution with rewinding is the only known input extraction strategy. 

The extractions itself depends who creates commitment parameters. If $\PK$ is generated inside $\PARTY_1^*$ then 
initial inputs $(\phi_1,x_1,\omega_1)$ together with $x_2$ completely fix the behaviour of $\PARTY_1^*$. Consequently, we can consider the following extraction strategy
\begin{align*}
\begin{fblock}{\IEXTR(\phi_1,x_1,\omega_1)}
& (\PK,c)\gets\PARTY_1^*(\phi_1,x_1,\omega_1)\\
& \begin{forblock}{x_2\in\XXX_2\ }
& d\gets\PARTY_1^*(x_2)\\
& \hat{x}_1\gets\OPEN_\PK(c,d)\\
& \IF \hat{x}_1\neq\bot\ \THEN \RETURN \hat{x}_1
& \end{forblock}\\
& \RETURN \bot\\
\end{fblock}
\end{align*}
where $\XXX_2$ is the set of all possible input values of the opponent $\PARTY_2$.
If $\PK$ is generated externally to $\PARTY_1^*$ then we additionally need $\PK$ to completely fix the behaviour of $\PARTY_1^*$. Thus, the plumbing between different components slightly changes 
\begin{align*}
\begin{fblock}{\IEXTR(\phi_1,x_1,\PK,\omega_1)}
& c\gets\PARTY_1^*(\phi_1,x_1,\PK,\omega_1)\\
& \begin{forblock}{x_2\in\XXX_2\ }
& d\gets\PARTY_1^*(x_2)\\
& \hat{x}_1\gets\OPEN_\PK(c,d)\\
& \IF \hat{x}_1\neq\bot\ \THEN \RETURN \hat{x}_1
& \end{forblock}\\
& \RETURN \bot\enspace.\\
\end{fblock}
\end{align*}


\medskip
\noindent
\textcolor{red}{
Prove the following facts
\begin{itemize}
\item If the commitment is perfectly binding then the protocol output $y_2$ of $\PARTY_2$ is the same in the real and ideal world. Note that the output is completely determined by the values $(\phi_1,x_1,\omega_1, x_2)$ and thus can be considered as a deterministic  function $y_2(\phi_1,x_1,\omega_1, x_2)$.
\item Show that iteration over all possible values $\XXX_2$ is essential for black-box extraction. For that you may consider the following adversary that releases $x_1$ only for a specific input $x_2$:
\begin{align*}
\begin{fblock}{\PARTY_2^*(\phi_1, x_1)}
&(\hat{x}_1, \hat{x}_2)\gets\phi_1\\
&\PK\gets\GEN\\
&(c,d)\gets\OPEN_\PK(\hat{x}_1)\\
&\text{Release $\PK$ and $c$. Store $x_2$}\\
&\IF x_2 =\hat{x}_2\ \THEN \text{Release $d$}\\
&\ELSE \text{Abort}
\end{fblock}
\end{align*}
Show that if $\IEXTR$ does not use some $x_2\in\XXX_2$ to extract input $\hat{x}_1$ then there exists inputs $(\phi_1,x_1)$ and $(\phi_2,x_2)$ such that the outcomes of $\PARTY_2$ are completely different in the real and ideal world.  
\item What does the previous result mean in terms of size of the input domains $\XXX_2$.
\item Show that the entire simulation construction is valid, i.e., the joint output distribution of $\PARTY_1$ and $\PARTY_2$ are identical if the commitment scheme is perfectly binding.  
\item Analyse what changes if we consider the setting with computationally binding commitments where $\PK$ is provided by $\PARTY_2$. 
\end{itemize}
}


\end{solution}
\end{document}

