\documentclass{crypto-exercise}
\contributor[Created the first draft solution]{Bingsheng Zhang}
\contributor[Added explanations for many corner cases]{Sven Laur}
\editor{Sven Laur}
\tags{security definition, hash functions, oracle calls}

\begin{document}
\begin{exercise}{Security of hash functions}
  A standard way to protect data against malicious corruption is
  hashing. Namely, there are many industry standard algorithms, like
  MD5, SHA-256 and WHIRLPOOL, that take in a long file and output a
  short digest. If the digest is securely stored, then the validity of
  the file can be tested by recomputing the digest and comparing it to
  the stored value.
  \begin{enumerate}
  \item Formalise the functional requirements and describe the attack
    scenario if the original data is generated by flipping a fair
    coin.
  \item Describe the attack scenario if an attacker gets to know the
    randomly generated original data before spoofing the file.
  \item Describe the attack scenario if attacker can influence the
    content of the original file. Show that no function can be secure
    against such attacks. What does it mean in real life applications?
  \end{enumerate}
\end{exercise}
\begin{solution}
  Let us consider the hash function $h: \MSPACE \rightarrow \DSPACE$
  with the message space $\MSPACE$ and the digest space $\DSPACE$. In
  practice, the message space often consist of all possible binary
  strings $\set{0,1}^*$. The first attack scenario where the data is
  random can be modelled as follows:
  \begin{align*}
    \begin{game}{\GAME_1^{\AD}}
      & x \getsu \MSPACE \\
      & x_* \gets \AD(h(x))\\
      & \RETURN [h(x_*)=h(x)]
    \end{game}
  \end{align*}
  if we assume that the adversary succeed when it provides any file
  that gives the same hash value. In other words, adversary is
  successful when it either reconstructs the original file or comes up
  with completely bogus one. When the files are long then restoring
  the original form the short hash is extremely unlikely and thus the
  first option never occurs in practice. Nevertheless, one could
  explicitly rule out the first option and come up with more strict
  security game
  \begin{align*}
    \begin{game}{\GAME_*^{\AD}}
      & x \getsu \MSPACE \\
      & x_* \gets \AD(h(x))\\
      & \RETURN [h(x_*)=h(x)\wedge x_*\neq x]\enspace.
    \end{game}
  \end{align*}
  The second attack scenario can be modelled through the following game
  \begin{align*}
    \begin{game}{\GAME_2^{\AD}}
      & x \getsu \MSPACE\\
      & x_* \gets  \AD(x)\\
      & \RETURN [ x_* \neq x \wedge h(x_*)=h(x)]\enspace.
    \end{game}
  \end{align*}
  Note that it is not necessary to give $h(x)$ to the adversary $\AD$,
  since the function $h$ is fixed and $\AD$ can compute $h(x)$ from
  $x$ directly. Here, the implicit assumption is that $h$ is
  efficiently computable function, which is one of the design goals
  for hash functions. If $h$ would be difficult to compute, then the
  fact whether we give $h(x)$ to $\AD$ or not could make a
  difference. But in this case one often assumes that $\AD$ can have
  oracle access to $h$ so that it could evaluate $h(x)$ for free. To
  be precise, we would then count oracle calls to $h$ separately and
  $\AD$ should still pay for preparing the argument $x$ and for
  reading the result $h(x)$. The corresponding security game is
  following
  \begin{align*}
    \begin{game}{\GAME_2^{\AD}}
      & x \getsu \MSPACE\\
      & x_* \gets  \AD^{h(\cdot)}(x)\\
      & \RETURN [ x_* \neq x \wedge h(x_*)=h(x)]\enspace
    \end{game}
  \end{align*}
  where the superscript $\AD^{h(\cdot)}$ emphasises that $\AD$ can
  make oracle calls to the function $h$.

  If the adversary $\AD$ can influence the content of the original
  file, then it can gear the content generation to the direction where
  it makes finding bogus files easier. At the limit $\AD$ has the
  power to specify the file completely and thus the third attack
  scenario can be modelled as the following game.
  \begin{align*}
    \begin{game}{\GAME_3^{\AD}}
      & (x_1,x_2) \gets  \AD\\
      & \RETURN [ x_1 \neq x_2 \wedge h(x_1)=h(x_2) ]\enspace.
    \end{game}
  \end{align*}
  Since the hash function $h$ is fixed in the game $G_3$, there exists
  an \emph{extremely efficient} adversary $\AD$ which just prints two
  constants $x_1$ and $x_2$ such that $h(x_1)=h(x_2)$. Therefore, no
  function can be secure for such game. However, in reality, we know
  such adversary exists, but we have no idea how to find such
  adversary, so there formalisation is somehow incorrect. One
  possibility is to choose hash function form a large function family
  $\HHH$:
  \begin{align*}
    \begin{game}{\GAME_*^{\AD}}
      & h\gets\HHH\\
      & (x_1,x_2) \gets  \AD(h)\\
      & \RETURN [ x_1 \neq x_2 \wedge h(x_1)=h(x_2) ]\enspace.
    \end{game}
  \end{align*}
  In this case, it is important that $\AD$ gets a description of $h$,
  briefly denoted by $\AD(h)$. As there are too many candidate
  functions, we cannot hardwire a collision table consisting of
  triples $(h, x_1, x_2)$ into $\AD$ and thus security against
  collisions is not ruled out by the design of the game. Also, note
  that the function family might assign different probabilities to
  different functions and thus $h$ is chosen according to the
  distribution of $\HHH$, emphasised by $h\gets \HHH$, and not
  uniformly, which is denoted by $h\getsu \HHH$ in our syntax.

\end{solution}

\end{document}

