\documentclass{crypto-exercise}
\author{Sven Laur}
\contributor[Created the first draft solution]{Sanja Šćepanović}
\contributor[Updated the first draft]{Bingsheng Zhang}
\contributor[Significantly expanded the original exposition]{Sven Laur}
\editor{Sven Laur}

\tags{simple reductions, Discrete Logarithm problem, incomplete
  solution, star exercise}

\begin{document}
\begin{exercise}{Hardness of discrete logarithm bits}
  Let $\GG=\langle g\rangle$ be a finite group of an odd order $q$
  generated by the powers of an element $g$. Then the Discrete
  Logarithm (DL) problem is following. For any element $y$ find a
  power $x\in\ZZ_q$ such that $g^x=y$.
  \begin{enumerate}
  \item Show that if there exists an efficient procedure that can
    always compute the highest bit of discrete logarithm then the DL
    problem is easy.
  \item Show that if there exists an efficient procedure that can
    always compute the lowest bit of discrete logarithm then the DL
    problem is easy.
  \item Show that if there exists an efficient procedure that can
    always compute two consecutive bits at positions $i$ and $i+1$ 
    then the DL problem is easy.
  \item[($\star$)] Show that if there exists an efficient procedure
    that can always compute the $i$th bit then the DL problem is
    easy. If it is not possible show the counterexample.
  \end{enumerate} 
\end{exercise}


\begin{solution}
  By construction the discrete logarithm is $\ceil{\log_2 q}$ bit
  number, further denoted by $\ell$. Before going any further, we make
  the following crucial observation. Let $x$ be the discrete logarithm
  of $y$. If the highest bit $x_\ell=0$ then squaring of $y$ leads to
  a group element with discrete logarithm $2x$. If $x_\ell=1$ then we
  get $2x+\kappa$ where $\kappa=2^{\ell+1}-q$. All our reductions uses
  this property to recover the discrete logarithm bit by bit.

  \paragraph{Highest bit.}
  Let $\AD$ is the magic algorithm that can always output the highest
  bit of discrete logarithm, i.e., $\AD(y)$ outputs the $\ell$th bit
  of $\log y$ for any $y\in\GG$. Then we can construct an adversary
  $\ADB$ can solve the DL problem as follows:
  \begin{align*}
    \begin{fblock}{\ADB^{\AD}(y)}
       & z \gets g^{2^\ell}\\
      &\begin{forblock}{i\in\set{1,\ldots,\ell}}
      & \alpha_{i} \gets \AD(y)\\
      &  y \gets (y\cdot  z^{-\alpha_i})^2\\
      \end{forblock}\\
      &\RETURN \alpha_{1}\alpha_2\ldots,\alpha_{\ell}\enspace.
    \end{fblock}
  \end{align*}
  Since $\AD$ is always correct the update first eliminates the
  $\ell$th bit and then shifts the power one position to left. As a
  consequence, we restore the discrete logarithm of $y$ bit by bit. If
  the running time of $\AD$ is $t_\AD$ then the running time of $\ADB$
  is $\Oh(\ell\cdot t_\AD+\ell)$.
  
  \paragraph{Lowest bit.}
  If $\AD$ can reconstruct the lowest bit then we can use squaring to
  detect the highest bit. Indeed, if the highest bit is zero then the
  lowers bit after squaring is also zero. If the highest bit is one
  then the lowers bit is one after squaring as $\kappa\equiv 1\pmod
  2$. This leads to the following reconstruction algorithm: 
  \begin{align*}
    \begin{fblock}{\ADB^{\AD}(y)}
      & \kappa \gets 2^{\ell+1}-q\\
      &\begin{forblock}{i\in\set{1,\ldots,\ell}}
      & y\gets y^2\\
      & \alpha_{i} \gets \AD(y)\\
      &  y \gets y g^{-\kappa \alpha_i}\\
      \end{forblock}\\
      &\RETURN \alpha_{1}\alpha_2\ldots,\alpha_{\ell}\enspace.
    \end{fblock}
  \end{align*}

  \paragraph{Two consecutive bits.}

\end{solution}

\end{document}
